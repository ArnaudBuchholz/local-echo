{"version":3,"file":"local-echo.js","mappings":"gEAEAA,EAAAA,KACAA,EAAQC,MAAQ,EAAhBD,G,SCyBA,IAxBA,IAAIE,EAAU,MAAQ,CACrB,SACA,SACA,KACA,SACA,SACA,YACA,KACA,OACA,OACA,aACCC,KAAK,KAAO,IACVC,EAAY,IAAIC,OAAO,IAAMH,EAAU,KACvCI,EAAO,cAGPC,EAAO,MAMPC,EAAQ,GAEHC,EAAI,EAAGA,EAAI,EAAGA,IACtBD,IAFU,WAEOE,KAAKC,UAAUC,SAAS,IAE1C,IAAIC,EAAkB,IAAIR,OAAO,IAAMG,GA8KvCM,EAAOd,QAAU,SAAee,EAAGC,EAAKC,GACvC,IAAIC,EA7IL,SAAuBC,EAAQH,EAAKC,GAC9BA,IACJA,EAAO,CAAC,GAET,IAAIG,EAAKH,EAAKI,QAAU,KAGpBC,EAAU,IAAIjB,OAAO,CACxB,IAAMH,EAAU,IAChB,OAJsBkB,EAAK,OAASd,EAAO,aAAeA,EAI1D,mDACCH,KAAK,KAAM,KAEToB,EA5CL,SAAkBR,EAAGS,GAMpB,IALA,IAGIC,EAHAC,EAAYF,EAAEG,UAEdJ,EAAU,GAGNE,EAAWD,EAAEI,KAAKb,IACzBQ,EAAQM,KAAKJ,GACTD,EAAEG,YAAcF,EAASK,QAC5BN,EAAEG,WAAa,GAMjB,OAFAH,EAAEG,UAAYD,EAEPH,CACR,CA4BeQ,CAASZ,EAAQG,GAE/B,GAAuB,IAAnBC,EAAQS,OACX,MAAO,GAEHhB,IACJA,EAAM,CAAC,GAGR,IAAIiB,GAAY,EAEhB,OAAOV,EAAQW,KAAI,SAAUC,GAC5B,IAAIpB,EAAIoB,EAAM,GACd,GAAKpB,IAAKkB,EAAV,CAGA,GAAI7B,EAAUgC,KAAKrB,GAClB,MAAO,CAAEsB,GAAItB,GAcd,IAIIN,EAJA6B,GAAQ,EACRC,GAAM,EACNC,EAAM,GACNC,GAAS,EAqCb,IAAKhC,EAAI,EAAGA,EAAIM,EAAEiB,OAAQvB,IAAK,CAC9B,IAAIiC,EAAI3B,EAAE4B,OAAOlC,GAEjB,GADAgC,EAASA,IAAYH,IAAgB,MAANI,GAAmB,MAANA,GACxCH,EACHC,GAAOE,EACPH,GAAM,OACA,GAAID,EACNI,IAAMJ,EACTA,GAAQ,EAtIJ,KAuIMA,EACVE,GAAOE,EAEHA,IAAMtB,GACTX,GAAK,EAGJ+B,GA7IE,OA2IHE,EAAI3B,EAAE4B,OAAOlC,KACGiC,IAAMtB,GA3InB,MA2IyBsB,EACpBA,EAEAtB,EAAKsB,GAGbF,GAjJG,MAgJOE,EACHE,IAEAF,OAGH,GAvJD,MAuJKA,GAxJL,MAwJiBA,EACtBJ,EAAQI,MACF,IAAItC,EAAUgC,KAAKM,GACzB,MAAO,CAAEL,GAAItB,GACP,GAAIR,EAAK6B,KAAKM,GAAI,CACxBT,GAAY,EACZ,IAAIY,EAAa,CAAEC,QAAS3B,EAAO4B,MAAMZ,EAAML,MAAQrB,EAAI,IAC3D,OAAI+B,EAAIR,OACA,CAACQ,EAAKK,GAEP,CAACA,EACT,CAAWH,IAAMtB,EAChBmB,GAAM,EAENC,GApKK,MAmKKE,EACHE,IAEAF,CACR,CACD,CAEA,OAAID,EACI,CAAEJ,GAAI,OAAQW,QAASR,GAGxBA,CA1GP,CAsBA,SAASI,IAER,IAAIK,EACAC,EAFJzC,GAAK,EAGL,IAAI0C,EAAOpC,EAAE4B,OAAOlC,GAEpB,GAAa,MAAT0C,EAAc,CAEjB,GADA1C,GAAK,EACe,MAAhBM,EAAE4B,OAAOlC,GACZ,MAAM,IAAI2C,MAAM,qBAAuBrC,EAAEgC,MAAMtC,EAAI,EAAGA,EAAI,IAG3D,IADAwC,EAASlC,EAAEsC,QAAQ,IAAK5C,IACX,EACZ,MAAM,IAAI2C,MAAM,qBAAuBrC,EAAEgC,MAAMtC,IAEhDyC,EAAUnC,EAAEgC,MAAMtC,EAAGwC,GACrBxC,EAAIwC,CACL,MAAO,GAAK,aAAcb,KAAKe,GAC9BD,EAAUC,EACV1C,GAAK,MACC,CACN,IAAI6C,EAAcvC,EAAEgC,MAAMtC,IAC1BwC,EAASK,EAAYnB,MAAM,cAK1Be,EAAUI,EAAYP,MAAM,EAAGE,EAAOnB,OACtCrB,GAAKwC,EAAOnB,MAAQ,IAJpBoB,EAAUI,EACV7C,EAAIM,EAAEiB,OAKR,CACA,OA9FH,SAAgBhB,EAAKuC,EAAKC,GACzB,IAAIhC,EAAmB,mBAARR,EAAqBA,EAAIwC,GAAOxC,EAAIwC,GAOnD,YANiB,IAANhC,GAA4B,IAAPgC,EAC/BhC,EAAI,QACmB,IAANA,IACjBA,EAAI,KAGY,iBAANA,EAsFU,GArFPhB,EAAQiD,KAAKC,UAAUlC,GAAKhB,EAqFrB,GAnFRgB,CACd,CAkFUmC,CAAO3C,EAAK,EAAIkC,EACxB,CAqDD,IAAGU,QAAO,SAAUC,EAAMC,GAEzB,YAAsB,IAARA,EAAsBD,EAAOA,EAAKE,OAAOD,EACxD,GAAG,GACJ,CAGcE,CAAcjD,EAAGC,EAAKC,GACnC,MAAmB,mBAARD,EACHE,EAEDA,EAAO0C,QAAO,SAAUK,EAAKlD,GACnC,GAAiB,iBAANA,EACV,OAAOkD,EAAIF,OAAOhD,GAEnB,IAAImD,EAAKnD,EAAEoD,MAAM9D,OAAO,IAAMG,EAAQ,MAAQA,EAAQ,IAAK,MAC3D,OAAkB,IAAd0D,EAAGlC,OACCiC,EAAIF,OAAOG,EAAG,IAEfD,EAAIF,OAAOG,EAAGE,OAAOC,SAASnC,KAAI,SAAUoC,GAClD,OAAIzD,EAAgBuB,KAAKkC,GACjBb,KAAKxD,MAAMqE,EAAEH,MAAM3D,GAAO,IAE3B8D,CACR,IACD,GAAG,GACJ,C,UC/NAxD,EAAOd,QAAU,SAAekE,GAC/B,OAAOA,EAAGhC,KAAI,SAAUnB,GACvB,OAAIA,GAAkB,iBAANA,EACRA,EAAEsB,GAAGkC,QAAQ,OAAQ,QAExB,QAASnC,KAAKrB,KAAQ,IAAKqB,KAAKrB,GAC7B,IAAMA,EAAEwD,QAAQ,WAAY,QAAU,IAEzC,SAAUnC,KAAKrB,GACZ,IAAMA,EAAEwD,QAAQ,cAAe,QAAU,IAE1CC,OAAOzD,GAAGwD,QAAQ,+CAAgD,SAC1E,IAAGpE,KAAK,IACT,C,GCdIsE,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAa5E,QAGrB,IAAIc,EAAS2D,EAAyBE,GAAY,CAGjD3E,QAAS,CAAC,GAOX,OAHA8E,EAAoBH,GAAU7D,EAAQA,EAAOd,QAAS0E,GAG/C5D,EAAOd,OACf,CCrBA0E,EAAoBK,EAAI,CAAC/E,EAASgF,KACjC,IAAI,IAAIxB,KAAOwB,EACXN,EAAoBO,EAAED,EAAYxB,KAASkB,EAAoBO,EAAEjF,EAASwD,IAC5E0B,OAAOC,eAAenF,EAASwD,EAAK,CAAE4B,YAAY,EAAMC,IAAKL,EAAWxB,IAE1E,ECNDkB,EAAoBO,EAAI,CAACK,EAAKC,IAAUL,OAAOM,UAAUC,eAAeC,KAAKJ,EAAKC,G,ysBCG3E,IAAMI,EAAiB,WAC5B,SAAAA,EAAYC,I,4FAAMC,CAAA,KAAAF,GAChBG,KAAKF,KAAOA,EACZE,KAAKC,QAAU,GACfD,KAAKE,OAAS,CAChB,C,QA0CC,O,EAxCDL,G,EAAA,EAAAnC,IAAA,OAAAyC,MAGA,SAAKC,GAEkB,KAAjBA,EAAMC,QAGND,GADcJ,KAAKC,QAAQD,KAAKC,QAAQ/D,OAAS,KAGrD8D,KAAKC,QAAQlE,KAAKqE,GACdJ,KAAKC,QAAQ/D,OAAS8D,KAAKF,MAC7BE,KAAKC,QAAQK,IAAI,GAEnBN,KAAKE,OAASF,KAAKC,QAAQ/D,OAC7B,GAEA,CAAAwB,IAAA,SAAAyC,MAGA,WACEH,KAAKE,OAASF,KAAKC,QAAQ/D,MAC7B,GAEA,CAAAwB,IAAA,cAAAyC,MAGA,WACE,IAAMI,EAAM3F,KAAK4F,IAAI,EAAGR,KAAKE,OAAS,GAEtC,OADAF,KAAKE,OAASK,EACPP,KAAKC,QAAQM,EACtB,GAEA,CAAA7C,IAAA,UAAAyC,MAGA,WACE,IAAMI,EAAM3F,KAAK6F,IAAIT,KAAKC,QAAQ/D,OAAQ8D,KAAKE,OAAS,GAExD,OADAF,KAAKE,OAASK,EACPP,KAAKC,QAAQM,EACtB,M,oEAACV,CAAA,CA/C2B,G,mHCEvB,SAASa,EAAeC,GAK7B,IALqD,IACjDtE,EADgCuE,IAAQC,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,KAAAA,UAAA,GAEtCC,EAAQ,GACRC,EAAK,OAEH1E,EAAQ0E,EAAGjF,KAAK6E,IAClBC,EACFE,EAAM/E,KAAKM,EAAML,OAEjB8E,EAAM/E,KAAKM,EAAML,MAAQK,EAAM,GAAGH,QAItC,OAAO4E,CACT,CAMO,SAASE,EAAoBL,EAAOM,GACzC,IAAMC,EAAQR,EAAeC,GAAO,GACjCQ,UACAC,MAAK,SAAA5C,GAAC,OAAIA,EAAIyC,CAAM,IACvB,OAAgB,MAATC,EAAgB,EAAIA,CAC7B,CAgCO,SAASG,EAAeV,EAAOM,EAAQK,GAC5C,IAAIC,EAAaZ,EACjBA,EAAQA,EAAMlC,QAAQ,0CAA2C,IACjEwC,GAAWM,EAAWrF,OAASyE,EAAMzE,OAKrC,IAHA,IA5B4BU,EA4BxB4E,EAAM,EACRC,EAAM,EAEC9G,EAAI,EAAGA,EAAIsG,IAAUtG,EAAG,CAC/B,IAAM+G,EAAMf,EAAM9D,OAAOlC,IACd,MAAP+G,IAIFD,GAnCD,yBAAyBnF,KAFAM,EAqCH8E,IA/BtB,gCAAgCpF,KAAKM,GAH/B,EAON,gcAAgcN,KAAKM,GAC/b,EAGF,GAwBO0E,KAJVG,EAAM,EACND,GAAO,EAQX,CAEA,MAAO,CAAEA,IAAAA,EAAKC,IAAAA,EAChB,CAKO,SAASE,EAAWhB,EAAOW,GAChC,OAAOD,EAAeV,EAAOA,EAAMzE,OAAQoF,GAASE,IAAM,CAC5D,CA8CO,SAASI,EAAqBjB,GACnC,OAAsC,MAA/BA,EAAMtE,MAAM,eACrB,CAKO,SAASwF,EAAalB,GAE3B,MAAqB,KAAjBA,EAAMN,QACNuB,EAAqBjB,GADO,IAIjBxG,EAAAA,EAAAA,OAAMwG,GACPL,OAAS,EACzB,CAmCO,SAASwB,EAAkBC,EAAUC,GAG1C,GAAID,EAAS7F,QAAU8F,EAAW,GAAG9F,OAAQ,OAAO6F,EAGpD,IAAME,EAAcF,EAGpBA,GAAYC,EAAW,GAAG/E,MAAM8E,EAAS7F,OAAQ6F,EAAS7F,OAAO,GAEjE,IAAK,IAAIvB,EAAE,EAAGA,EAAEqH,EAAW9F,OAAQvB,IAAM,CAGvC,IAAKqH,EAAWrH,GAAGuH,WAAWD,GAAc,OAAO,KAEnD,IAAKD,EAAWrH,GAAGuH,WAAWH,GAC5B,OAAOE,CAEX,CAEA,OAAOH,EAAkBC,EAAUC,EACrC,C,mqBCrMA,IAWqBG,EAAmB,WACtC,SAAAA,IAAuC,IAA3BC,EAAIvB,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,GAAAA,UAAA,GAAG,KAAMwB,EAAOxB,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,GAAAA,UAAA,GAAG,CAAC,G,4FAACd,CAAA,KAAAoC,GACnCnC,KAAKoC,KAAOA,EACZpC,KAAKsC,gBAAkBtC,KAAKuC,eAAeC,KAAKxC,MAChDA,KAAKyC,kBAAoBzC,KAAK0C,iBAAiBF,KAAKxC,MAEpDA,KAAK2C,QAAU,IAAI9C,EAAkBwC,EAAQO,aAAe,IAC5D5C,KAAK6C,uBAAyBR,EAAQQ,wBAA0B,IAEhE7C,KAAK8C,sBAAwB,GAC7B9C,KAAK+C,SAAU,EACf/C,KAAKgD,OAAS,GACdhD,KAAKiD,QAAU,EACfjD,KAAKkD,cAAgB,KACrBlD,KAAKmD,kBAAoB,KACzBnD,KAAKoD,UAAY,CACfC,KAAM,EACNC,KAAM,GAGRtD,KAAKuD,aAAe,GAEhBnB,IACEA,EAAKoB,UAAWpB,EAAKoB,UAAUxD,MAC9BA,KAAKyD,SAEd,C,QAukBC,O,EArkBDtB,E,EAAA,EAAAzE,IAAA,WAAAyC,MACA,SAASiC,GACPpC,KAAKoC,KAAOA,EACZpC,KAAKyD,QACP,GAAC,CAAA/F,IAAA,UAAAyC,MACD,WACEH,KAAK0D,QACP,GAMA,CAAAhG,IAAA,SAAAyC,MAGA,WACMH,KAAKoC,KAAKuB,KACZ3D,KAAKoC,KAAKuB,IAAI,OAAQ3D,KAAKsC,iBAC3BtC,KAAKoC,KAAKuB,IAAI,SAAU3D,KAAKyC,qBAE7BzC,KAAKuD,aAAaK,SAAQ,SAAA3E,GAAC,OAAIA,EAAE4E,SAAS,IAC1C7D,KAAKuD,aAAe,GAExB,GAEA,CAAA7F,IAAA,SAAAyC,MAGA,WACMH,KAAKoC,KAAK0B,IACZ9D,KAAKoC,KAAK0B,GAAG,OAAQ9D,KAAKsC,iBAC1BtC,KAAKoC,KAAK0B,GAAG,SAAU9D,KAAKyC,qBAE5BzC,KAAKuD,aAAaxH,KAAKiE,KAAKoC,KAAK2B,OAAO/D,KAAKsC,kBAC7CtC,KAAKuD,aAAaxH,KAAKiE,KAAKoC,KAAK4B,SAAShE,KAAKyC,qBAEjDzC,KAAKoD,UAAY,CACfC,KAAMrD,KAAKoC,KAAKiB,KAChBC,KAAMtD,KAAKoC,KAAKkB,KAEpB,GAEA,CAAA5F,IAAA,yBAAAyC,MAGA,SAAuB8D,GAAa,QAAAC,EAAArD,UAAA3E,OAANiI,EAAI,IAAAC,MAAAF,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAAJF,EAAIE,EAAA,GAAAxD,UAAAwD,GAChCrE,KAAK8C,sBAAsB/G,KAAK,CAC9BkI,GAAAA,EACAE,KAAAA,GAEJ,GAEA,CAAAzG,IAAA,4BAAAyC,MAGA,SAA0B8D,GACxB,IAAM1D,EAAMP,KAAK8C,sBAAsBwB,WAAU,SAAAC,GAAC,OAAIA,EAAEN,KAAOA,CAAE,KACpD,IAAT1D,GAEJP,KAAK8C,sBAAsB0B,OAAOjE,EAAK,EACzC,GAEA,CAAA7C,IAAA,OAAAyC,MAIA,SAAKsE,GAAmC,IAAAC,EAAA,KAA3BC,EAAkB9D,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,GAAAA,UAAA,GAAG,KAChC,OAAO,IAAI+D,SAAQ,SAACC,EAASC,GAC3BJ,EAAKtC,KAAK2C,MAAMN,GAChBC,EAAKxB,cAAgB,CACnBuB,OAAAA,EACAE,mBAAAA,EACAE,QAAAA,EACAC,OAAAA,GAGFJ,EAAK1B,OAAS,GACd0B,EAAKzB,QAAU,EACfyB,EAAK3B,SAAU,CACjB,GACF,GAEA,CAAArF,IAAA,WAAAyC,MAOA,SAASsE,GAAQ,IAAAO,EAAA,KACf,OAAO,IAAIJ,SAAQ,SAACC,EAASC,GAC3BE,EAAK5C,KAAK2C,MAAMN,GAChBO,EAAK7B,kBAAoB,CACvBsB,OAAAA,EACAI,QAAAA,EACAC,OAAAA,EAEJ,GACF,GAEA,CAAApH,IAAA,YAAAyC,MAGA,WAA8B,IAApB8E,EAAMpE,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,GAAAA,UAAA,GAAG,UACS,MAAtBb,KAAKkD,eAAmD,MAA1BlD,KAAKmD,mBACrCnD,KAAKoC,KAAK2C,MAAM,QAEQ,MAAtB/E,KAAKkD,gBACPlD,KAAKkD,cAAc4B,OAAOG,GAC1BjF,KAAKkD,cAAgB,MAEO,MAA1BlD,KAAKmD,oBACPnD,KAAKmD,kBAAkB2B,OAAOG,GAC9BjF,KAAKmD,kBAAoB,MAE3BnD,KAAK+C,SAAU,CACjB,GAEA,CAAArF,IAAA,UAAAyC,MAGA,SAAQ+E,GACNlF,KAAKmF,MAAMD,EAAU,KACvB,GAEA,CAAAxH,IAAA,QAAAyC,MAGA,SAAM+E,GACJ,IAAME,EAAYF,EAAQzG,QAAQ,WAAY,MAC9CuB,KAAKoC,KAAK2C,MAAMK,EAAU3G,QAAQ,MAAO,QAC3C,GAEA,CAAAf,IAAA,YAAAyC,MAGA,SAAUkF,GAAoB,IAAbC,EAAOzE,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,GAAAA,UAAA,GAAG,EACzB,GAAoB,GAAhBwE,EAAMnJ,OAAa,OAAO8D,KAAKuF,QAAQ,IAU3C,IAPA,IAAMC,EACJH,EAAMvH,QAAO,SAAC2H,EAAOC,GAAI,OAAK9K,KAAK4F,IAAIiF,EAAOC,EAAKxJ,OAAO,GAAE,GAAKoJ,EAC7DK,EAAW/K,KAAKgL,MAAM5F,KAAKoD,UAAUC,KAAOmC,GAC5CK,EAAWjL,KAAKkL,KAAKT,EAAMnJ,OAASyJ,GAGtChL,EAAI,EACC6G,EAAM,EAAGA,EAAMqE,IAAYrE,EAAK,CAIvC,IAHA,IAAIuE,EAAS,GAGJtE,EAAM,EAAGA,EAAMkE,IAAYlE,EAClC,GAAI9G,EAAI0K,EAAMnJ,OAAQ,CACpB,IAAIwJ,EAAOL,EAAM1K,KAEjBoL,GADAL,GAAQ,IAAIM,OAAOR,EAAYE,EAAKxJ,OAEtC,CAEF8D,KAAKuF,QAAQQ,EACf,CACF,GAMA,CAAArI,IAAA,eAAAyC,MAGA,SAAaQ,GACX,IAAM8D,GAAUzE,KAAKkD,eAAiB,CAAC,GAAGuB,QAAU,GAC9CE,GACH3E,KAAKkD,eAAiB,CAAC,GAAGyB,oBAAsB,GAEnD,OAAOF,EAAS9D,EAAMlC,QAAQ,MAAO,KAAOkG,EAC9C,GAEA,CAAAjH,IAAA,oBAAAyC,MAIA,SAAkBQ,EAAOM,GAEvB,OADiBjB,KAAKiG,aAAatF,EAAMuF,OAAO,EAAGjF,IACnC/E,MAClB,GAEA,CAAAwB,IAAA,aAAAyC,MAMA,WAgBE,IAfA,IAAMgG,EAAgBnG,KAAKiG,aAAajG,KAAKgD,QAGvCoD,EAAUzE,EAAWwE,EAAenG,KAAKoD,UAAUC,MAIzDgD,EAAqBhF,EACnB8E,EAFmBnG,KAAKsG,kBAAkBtG,KAAKgD,OAAQhD,KAAKiD,SAI5DjD,KAAKoD,UAAUC,MAIXkD,GAPKF,EAAH5E,IAOS2E,EAPDC,EAAH7E,IAOoB,GACxB7G,EAAI,EAAGA,EAAI4L,IAAY5L,EAAGqF,KAAKoC,KAAK2C,MAAM,OAInD,IADA/E,KAAKoC,KAAK2C,MAAM,SACPpK,EAAI,EAAGA,EAAIyL,IAAWzL,EAAGqF,KAAKoC,KAAK2C,MAAM,SACpD,GAEA,CAAArH,IAAA,WAAAyC,MAMA,SAASqG,MAAoB3F,UAAA3E,OAAA,QAAA6C,IAAA8B,UAAA,KAAAA,UAAA,KAEXb,KAAKyG,aAGrB,IAAMC,EAAY1G,KAAKiG,aAAaO,GACpCxG,KAAKmF,MAAMuB,GAGP1G,KAAKiD,QAAUuD,EAAStK,SAC1B8D,KAAKiD,QAAUuD,EAAStK,QAI1B,IAAMyK,EAAY3G,KAAKsG,kBAAkBE,EAAUxG,KAAKiD,SAClD2D,EAAWjF,EAAW+E,EAAW1G,KAAKoD,UAAUC,MACtDwD,EAAqBxF,EACnBqF,EACAC,EACA3G,KAAKoD,UAAUC,MAHT5B,EAAGoF,EAAHpF,IAKFqF,EAAaF,EALHC,EAAHrF,IAKuB,EAEpCxB,KAAKoC,KAAK2C,MAAM,MAChB,IAAK,IAAIpK,EAAI,EAAGA,EAAImM,IAAcnM,EAAGqF,KAAKoC,KAAK2C,MAAM,OACrD,IAASpK,EAAI,EAAGA,EAAI8G,IAAO9G,EAAGqF,KAAKoC,KAAK2C,MAAM,OAG9C/E,KAAKgD,OAASwD,CAChB,GAEA,CAAA9I,IAAA,wBAAAyC,MAIA,SAAsB4G,GAAU,IAAAC,EAAA,KACxB9G,EAASF,KAAKiD,QAGpBjD,KAAKiH,UAAUjH,KAAKgD,OAAO9G,QAC3B8D,KAAKoC,KAAK2C,MAAM,QAGhB,IAAMmC,EAAS,WACbF,EAAK/D,QAAU/C,EACf8G,EAAKG,SAASH,EAAKhE,OACrB,EAIMoE,EAAML,IACD,MAAPK,EACFF,IAEAE,EAAIC,KAAKH,EAEb,GAEA,CAAAxJ,IAAA,YAAAyC,MAMA,SAAUwG,GACJA,EAAY,IAAGA,EAAY,GAC3BA,EAAY3G,KAAKgD,OAAO9G,SAAQyK,EAAY3G,KAAKgD,OAAO9G,QAG5D,IAAMoL,EAAkBtH,KAAKiG,aAAajG,KAAKgD,QAK/CuE,GAJmB5F,EAAW2F,EAAiBtH,KAAKoD,UAAUC,MAIvBhC,EACrCiG,EAFuBtH,KAAKsG,kBAAkBtG,KAAKgD,OAAQhD,KAAKiD,SAIhEjD,KAAKoD,UAAUC,OAHJmE,EAAOD,EAAZ9F,IAAmBgG,EAAOF,EAAZ/F,IAQtBkG,EAAqCrG,EACnCiG,EAFsBtH,KAAKsG,kBAAkBtG,KAAKgD,OAAQ2D,GAI1D3G,KAAKoD,UAAUC,MAHJsE,EAAMD,EAAXjG,IAAkBmG,EAAMF,EAAXlG,IAOrB,GAAIoG,EAASH,EACX,IAAK,IAAI9M,EAAI8M,EAAS9M,EAAIiN,IAAUjN,EAAGqF,KAAKoC,KAAK2C,MAAM,YAEvD,IAAK,IAAIpK,EAAIiN,EAAQjN,EAAI8M,IAAW9M,EAAGqF,KAAKoC,KAAK2C,MAAM,OAIzD,GAAI4C,EAASH,EACX,IAAK,IAAI7M,EAAI6M,EAAS7M,EAAIgN,IAAUhN,EAAGqF,KAAKoC,KAAK2C,MAAM,YAEvD,IAAK,IAAIpK,EAAIgN,EAAQhN,EAAI6M,IAAW7M,EAAGqF,KAAKoC,KAAK2C,MAAM,OAIzD/E,KAAKiD,QAAU0D,CACjB,GAEA,CAAAjJ,IAAA,mBAAAyC,MAGA,SAAiB0H,GACf,GAAIA,EAAM,EAAG,CACX,IAAMC,EAAMlN,KAAK6F,IAAIoH,EAAK7H,KAAKgD,OAAO9G,OAAS8D,KAAKiD,SACpDjD,KAAKiH,UAAUjH,KAAKiD,QAAU6E,EAChC,MAAO,GAAID,EAAM,EAAG,CAClB,IAAMC,EAAMlN,KAAK4F,IAAIqH,GAAM7H,KAAKiD,SAChCjD,KAAKiH,UAAUjH,KAAKiD,QAAU6E,EAChC,CACF,GAEA,CAAApK,IAAA,oBAAAyC,MAGA,SAAkB4H,GAChB,IAAQ9E,EAAoBjD,KAApBiD,QAASD,EAAWhD,KAAXgD,OACjB,GAAI+E,EAAW,CACb,GAAI9E,GAAW,EAAG,OAClB,IAAMuD,EAAWxD,EAAOkD,OAAO,EAAGjD,EAAU,GAAKD,EAAOkD,OAAOjD,GAC/DjD,KAAKyG,aACLzG,KAAKiD,SAAW,EAChBjD,KAAKmH,SAASX,GAAU,EAC1B,KAAO,CACL,IAAMA,EAAWxD,EAAOkD,OAAO,EAAGjD,GAAWD,EAAOkD,OAAOjD,EAAU,GACrEjD,KAAKmH,SAASX,EAChB,CACF,GAEA,CAAA9I,IAAA,qBAAAyC,MAGA,SAAmB6H,GACjB,IAAQ/E,EAAoBjD,KAApBiD,QAASD,EAAWhD,KAAXgD,OACXwD,EAAWxD,EAAOkD,OAAO,EAAGjD,GAAW+E,EAAOhF,EAAOkD,OAAOjD,GAClEjD,KAAKiD,SAAW+E,EAAK9L,OACrB8D,KAAKmH,SAASX,EAChB,GAEA,CAAA9I,IAAA,qBAAAyC,MAGA,WACMH,KAAK2C,SACP3C,KAAK2C,QAAQ5G,KAAKiE,KAAKgD,QAErBhD,KAAKkD,gBACPlD,KAAKkD,cAAc2B,QAAQ7E,KAAKgD,QAChChD,KAAKkD,cAAgB,MAEvBlD,KAAKoC,KAAK2C,MAAM,QAChB/E,KAAK+C,SAAU,CACjB,GAEA,CAAArF,IAAA,mBAAAyC,MAOA,SAAiB6H,GACf,IAAQ1E,EAAe0E,EAAf1E,KAAMD,EAAS2E,EAAT3E,KACdrD,KAAKyG,aACLzG,KAAKoD,UAAY,CAAEC,KAAAA,EAAMC,KAAAA,GACzBtD,KAAKmH,SAASnH,KAAKgD,QAAQ,EAC7B,GAEA,CAAAtF,IAAA,iBAAAyC,MAGA,SAAe6H,GAAM,IAAAC,EAAA,KACnB,GAAKjI,KAAK+C,QAAV,CAGA,GAA8B,MAA1B/C,KAAKmD,kBAIP,OAHAnD,KAAKmD,kBAAkB0B,QAAQmD,GAC/BhI,KAAKmD,kBAAoB,UACzBnD,KAAKoC,KAAK2C,MAAM,QAKlB,GAAIiD,EAAK9L,OAAS,GAA4B,KAAvB8L,EAAKE,WAAW,GAAa,CAClD,IAAMC,EAAWH,EAAKvJ,QAAQ,WAAY,MAC1C2F,MAAMgE,KAAKD,GAAUvE,SAAQ,SAAAhH,GAAC,OAAIqL,EAAKI,WAAWzL,EAAE,GACtD,MACEoD,KAAKqI,WAAWL,EAfO,CAiB3B,GAEA,CAAAtK,IAAA,aAAAyC,MAGA,SAAW6H,GAAM,IAAAM,EAAA,KACf,GAAKtI,KAAK+C,QAAV,CACA,IACIwF,ED/b6B5H,EAAOM,EACpCC,EC6bEsH,EAAMR,EAAKE,WAAW,GAI5B,GAAW,IAAPM,EACF,OAAQR,EAAK9B,OAAO,IAClB,IAAK,KACH,GAAIlG,KAAK2C,QAAS,CAChB,IAAIxC,EAAQH,KAAK2C,QAAQ8F,cACrBtI,IACFH,KAAKmH,SAAShH,GACdH,KAAKiH,UAAU9G,EAAMjE,QAEzB,CACA,MAEF,IAAK,KACH,GAAI8D,KAAK2C,QAAS,CAChB,IAAIxC,EAAQH,KAAK2C,QAAQ+F,UACpBvI,IAAOA,EAAQ,IACpBH,KAAKmH,SAAShH,GACdH,KAAKiH,UAAU9G,EAAMjE,OACvB,CACA,MAEF,IAAK,KACH8D,KAAK2I,kBAAkB,GACvB,MAEF,IAAK,KACH3I,KAAK2I,iBAAiB,GACtB,MAEF,IAAK,MACH3I,KAAK4I,mBAAkB,GACvB,MAEF,IAAK,KACH5I,KAAKiH,UAAUjH,KAAKgD,OAAO9G,QAC3B,MAEF,IAAK,KACH8D,KAAKiH,UAAU,GACf,MAEF,IAAK,IAEQ,OADXsB,EAAMvH,EAAoBhB,KAAKgD,OAAQhD,KAAKiD,WAC3BjD,KAAKiH,UAAUsB,GAChC,MAEF,IAAK,IDhfwB5H,ECifAX,KAAKgD,ODjfE/B,ECifMjB,KAAKiD,QAClC,OADXsF,ED/eQ,OADVrH,EAAQR,EAAeC,GAAO,GAAOS,MAAK,SAAA5C,GAAC,OAAIA,EAAIyC,CAAM,KACxCN,EAAMzE,OAASgF,ICgfblB,KAAKiH,UAAUsB,GAChC,MAEF,IAAK,IAEQ,OADXA,EAAMvH,EAAoBhB,KAAKgD,OAAQhD,KAAKiD,YAE1CjD,KAAKmH,SACHnH,KAAKgD,OAAOkD,OAAO,EAAGqC,GAAOvI,KAAKgD,OAAOkD,OAAOlG,KAAKiD,UAEvDjD,KAAKiH,UAAUsB,SAMhB,GAAIC,EAAM,IAAc,MAARA,EACrB,OAAQR,GACN,IAAK,MD1bN,SAA2BrH,GAEhC,MAAoB,IAAhBA,EAAMN,UAKLM,EAAMtE,MAAM,OAAS,IAAIH,OAAS,GAAM,IAIxCyE,EAAMtE,MAAM,OAAS,IAAIH,OAAS,GAAM,GAQ9B,IAHbyE,EACGtC,MAAM,iBACNiC,MACAD,WAKDM,EAAMkI,SAAS,OAAUlI,EAAMkI,SAAS,SAK9C,CC8ZcC,CAAkB9I,KAAKgD,QAGzBhD,KAAK+I,qBAFL/I,KAAKgJ,mBAAmB,MAI1B,MAEF,IAAK,IACHhJ,KAAK4I,mBAAkB,GACvB,MAEF,IAAK,KACH,GAAI5I,KAAK8C,sBAAsB5G,OAAS,EAAG,CACzC,IAAM+M,EAAgBjJ,KAAKgD,OAAOkD,OAAO,EAAGlG,KAAKiD,SAC3CiG,EAAkBtH,EAAqBqH,GACvCjH,EDpZX,SAAuCmH,EAAWxI,GACvD,IAAMyI,GAASjP,EAAAA,EAAAA,OAAMwG,GACjB3E,EAAQoN,EAAOlN,OAAS,EACxBmN,EAAOD,EAAOpN,IAAU,GAuB5B,MApBqB,KAAjB2E,EAAMN,QACRrE,EAAQ,EACRqN,EAAO,IACEzH,EAAqBjB,KAE9B3E,GAAS,EACTqN,EAAO,IAIGF,EAAUrL,QAAO,SAACkE,EAAUsH,GAAmB,I,EAAfrF,EAAEqF,EAAFrF,GAAIE,EAAImF,EAAJnF,KAC9C,IACE,OAAOnC,EAAW/D,OAAOgG,EAAEsF,WAAC,EAAD,CAACvN,EAAOoN,GAAMnL,O,+CAAKkG,I,kkBAChD,CAAE,MAAOI,GAEP,OADAiF,QAAQC,MAAM,uBAAwBlF,GAC/BvC,CACT,CACF,GAAG,IAGQ1D,QAAO,SAAAoL,GAAG,OAAIA,EAAIxH,WAAWmH,EAAK,GAC/C,CCyX+BM,CACjB3J,KAAK8C,sBACLmG,GAQF,GAJAjH,EAAW4H,OAIe,IAAtB5H,EAAW9F,OAERgN,GACHlJ,KAAKgJ,mBAAmB,UAErB,GAA0B,IAAtBhH,EAAW9F,OAAc,CAElC,IAAM2N,EAAYhI,EAAaoH,GAC/BjJ,KAAKgJ,mBACHhH,EAAW,GAAGkE,OAAO2D,EAAU3N,QAAU,IAE7C,MAAO,GAAI8F,EAAW9F,QAAU8D,KAAK6C,uBAAwB,CAG3D,IAAMiH,EAAehI,EAAkBmH,EAAejH,GAItD,GAAI8H,EAAc,CAChB,IAAMD,EAAYhI,EAAaoH,GAC/BjJ,KAAKgJ,mBACHc,EAAa5D,OAAO2D,EAAU3N,QAElC,CAIA8D,KAAK+J,uBAAsB,WACzBzB,EAAK0B,UAAUhI,EACjB,GACF,MAGEhC,KAAK+J,uBAAsB,kBACzBzB,EAAK2B,SAAS,eAADhM,OACI+D,EAAW9F,OAAM,6BAChCmL,MAAK,SAAA6C,GACK,KAANA,GAAmB,KAANA,GACf5B,EAAK0B,UAAUhI,EAEnB,GAAE,GAGR,MACEhC,KAAKgJ,mBAAmB,QAE1B,MAEF,IAAK,IACHhJ,KAAKiH,UAAUjH,KAAKgD,OAAO9G,QAC3B8D,KAAKoC,KAAK2C,MAAM,WAAa/E,KAAKkD,eAAiB,CAAC,GAAGuB,QAAU,KACjEzE,KAAKgD,OAAS,GACdhD,KAAKiD,QAAU,EACXjD,KAAK2C,SAAS3C,KAAK2C,QAAQwH,cAMnCnK,KAAKgJ,mBAAmBhB,EA3JD,CA6J3B,I,uEAAC7F,CAAA,CAjmBqC,GCrBxC,S","sources":["webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./node_modules/shell-quote/parse.js","webpack://LocalEchoController/./node_modules/shell-quote/quote.js","webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/webpack/runtime/define property getters","webpack://LocalEchoController/webpack/runtime/hasOwnProperty shorthand","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"sourcesContent":["'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.pop(0);\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","import { parse } from \"shell-quote\";\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Returns the word at the given offset.\r\n */\r\nexport function calcWordWidth(c) {\r\n  // Zero width\r\n  if(/[\\u200B-\\u200D\\uFEFF]/g.test(c)) {\r\n    return 0;\r\n  }\r\n  // Special characters\r\n  if(/[\\u0591-\\u05F4\\uFB1D-\\uFBF4]/g.test(c)) {\r\n    return 0;\r\n  }\r\n  // Wide characters\r\n  if(/[\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u31FF\\u3200-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u33FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]/g.test(c)) {\r\n    return 2;\r\n  }\r\n  // Combining characters\r\n  return 1;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let ansi_input = input\r\n  input = input.replace(/\\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g, '')\r\n  offset -= (ansi_input.length - input.length)\r\n  \r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += calcWordWidth(chr);\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\][ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n    \r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n    \r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  \r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return this.println(\"\");\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.length);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substr(0, offset));\r\n    return newInput.length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substr(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substr(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace) {\r\n                this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              const lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substr(lastToken.length) + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const sameFragment = getSharedFragment(inputFragment, candidates);\r\n              \r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                const lastToken = getLastToken(inputFragment);\r\n                this.handleCursorInsert(\r\n                  sameFragment.substr(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // If we are less than maximum auto-complete candidates, print\r\n              // them to the user and re-start prompt\r\n              this.printAndRestartPrompt(() => {\r\n                this.printWide(candidates);\r\n              });\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"names":["exports","parse","CONTROL","join","controlRE","RegExp","META","hash","TOKEN","i","Math","random","toString","startsWithToken","module","s","env","opts","mapped","string","BS","escape","chunker","matches","r","matchObj","origIndex","lastIndex","exec","push","index","matchAll","length","commented","map","match","test","op","quote","esc","out","isGlob","c","charAt","parseEnvVar","commentObj","comment","slice","pattern","varend","varname","char","Error","indexOf","slicedFromI","pre","key","JSON","stringify","getVar","reduce","prev","arg","concat","parseInternal","acc","xs","split","filter","Boolean","x","replace","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","HistoryController","size","_classCallCheck","this","entries","cursor","value","entry","trim","pop","idx","max","min","wordBoundaries","input","leftSide","arguments","words","rx","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","ansi_input","row","col","chr","countLines","hasTailingWhitespace","getLastToken","getSharedFragment","fragment","candidates","oldFragment","startsWith","LocalEchoController","term","options","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","fn","_len","args","Array","_key","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","_this2","reason","message","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","substr","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","callback","_this3","setCursor","resume","setInput","ret","then","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","backspace","data","_this4","charCodeAt","normData","from","handleData","_this5","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","hasTailingSpace","callbacks","tokens","expr","_ref","apply","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","printAndRestartPrompt","printWide","readChar","yn","rewind"],"sourceRoot":""}