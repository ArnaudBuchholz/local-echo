{"version":3,"file":"local-echo.js","mappings":"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","sources":["webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./node_modules/shell-quote/parse.js","webpack://LocalEchoController/./node_modules/shell-quote/quote.js","webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/webpack/runtime/define property getters","webpack://LocalEchoController/webpack/runtime/hasOwnProperty shorthand","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"sourcesContent":["'use strict';\n\nexports.quote = require('./quote');\nexports.parse = require('./parse');\n","'use strict';\n\n// '<(' is process substitution operator and\n// can be parsed the same as control operator\nvar CONTROL = '(?:' + [\n\t'\\\\|\\\\|',\n\t'\\\\&\\\\&',\n\t';;',\n\t'\\\\|\\\\&',\n\t'\\\\<\\\\(',\n\t'\\\\<\\\\<\\\\<',\n\t'>>',\n\t'>\\\\&',\n\t'<\\\\&',\n\t'[&;()|<>]'\n].join('|') + ')';\nvar controlRE = new RegExp('^' + CONTROL + '$');\nvar META = '|&;()<> \\\\t';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\nvar hash = /^#$/;\n\nvar SQ = \"'\";\nvar DQ = '\"';\nvar DS = '$';\n\nvar TOKEN = '';\nvar mult = 0x100000000; // Math.pow(16, 8);\nfor (var i = 0; i < 4; i++) {\n\tTOKEN += (mult * Math.random()).toString(16);\n}\nvar startsWithToken = new RegExp('^' + TOKEN);\n\nfunction matchAll(s, r) {\n\tvar origIndex = r.lastIndex;\n\n\tvar matches = [];\n\tvar matchObj;\n\n\twhile ((matchObj = r.exec(s))) {\n\t\tmatches.push(matchObj);\n\t\tif (r.lastIndex === matchObj.index) {\n\t\t\tr.lastIndex += 1;\n\t\t}\n\t}\n\n\tr.lastIndex = origIndex;\n\n\treturn matches;\n}\n\nfunction getVar(env, pre, key) {\n\tvar r = typeof env === 'function' ? env(key) : env[key];\n\tif (typeof r === 'undefined' && key != '') {\n\t\tr = '';\n\t} else if (typeof r === 'undefined') {\n\t\tr = '$';\n\t}\n\n\tif (typeof r === 'object') {\n\t\treturn pre + TOKEN + JSON.stringify(r) + TOKEN;\n\t}\n\treturn pre + r;\n}\n\nfunction parseInternal(string, env, opts) {\n\tif (!opts) {\n\t\topts = {};\n\t}\n\tvar BS = opts.escape || '\\\\';\n\tvar BAREWORD = '(\\\\' + BS + '[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\n\n\tvar chunker = new RegExp([\n\t\t'(' + CONTROL + ')', // control chars\n\t\t'(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')+'\n\t].join('|'), 'g');\n\n\tvar matches = matchAll(string, chunker);\n\n\tif (matches.length === 0) {\n\t\treturn [];\n\t}\n\tif (!env) {\n\t\tenv = {};\n\t}\n\n\tvar commented = false;\n\n\treturn matches.map(function (match) {\n\t\tvar s = match[0];\n\t\tif (!s || commented) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tif (controlRE.test(s)) {\n\t\t\treturn { op: s };\n\t\t}\n\n\t\t// Hand-written scanner/parser for Bash quoting rules:\n\t\t//\n\t\t// 1. inside single quotes, all characters are printed literally.\n\t\t// 2. inside double quotes, all characters are printed literally\n\t\t//    except variables prefixed by '$' and backslashes followed by\n\t\t//    either a double quote or another backslash.\n\t\t// 3. outside of any quotes, backslashes are treated as escape\n\t\t//    characters and not printed (unless they are themselves escaped)\n\t\t// 4. quote context can switch mid-token if there is no whitespace\n\t\t//     between the two quote contexts (e.g. all'one'\"token\" parses as\n\t\t//     \"allonetoken\")\n\t\tvar quote = false;\n\t\tvar esc = false;\n\t\tvar out = '';\n\t\tvar isGlob = false;\n\t\tvar i;\n\n\t\tfunction parseEnvVar() {\n\t\t\ti += 1;\n\t\t\tvar varend;\n\t\t\tvar varname;\n\t\t\tvar char = s.charAt(i);\n\n\t\t\tif (char === '{') {\n\t\t\t\ti += 1;\n\t\t\t\tif (s.charAt(i) === '}') {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i - 2, i + 1));\n\t\t\t\t}\n\t\t\t\tvarend = s.indexOf('}', i);\n\t\t\t\tif (varend < 0) {\n\t\t\t\t\tthrow new Error('Bad substitution: ' + s.slice(i));\n\t\t\t\t}\n\t\t\t\tvarname = s.slice(i, varend);\n\t\t\t\ti = varend;\n\t\t\t} else if ((/[*@#?$!_-]/).test(char)) {\n\t\t\t\tvarname = char;\n\t\t\t\ti += 1;\n\t\t\t} else {\n\t\t\t\tvar slicedFromI = s.slice(i);\n\t\t\t\tvarend = slicedFromI.match(/[^\\w\\d_]/);\n\t\t\t\tif (!varend) {\n\t\t\t\t\tvarname = slicedFromI;\n\t\t\t\t\ti = s.length;\n\t\t\t\t} else {\n\t\t\t\t\tvarname = slicedFromI.slice(0, varend.index);\n\t\t\t\t\ti += varend.index - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn getVar(env, '', varname);\n\t\t}\n\n\t\tfor (i = 0; i < s.length; i++) {\n\t\t\tvar c = s.charAt(i);\n\t\t\tisGlob = isGlob || (!quote && (c === '*' || c === '?'));\n\t\t\tif (esc) {\n\t\t\t\tout += c;\n\t\t\t\tesc = false;\n\t\t\t} else if (quote) {\n\t\t\t\tif (c === quote) {\n\t\t\t\t\tquote = false;\n\t\t\t\t} else if (quote == SQ) {\n\t\t\t\t\tout += c;\n\t\t\t\t} else { // Double quote\n\t\t\t\t\tif (c === BS) {\n\t\t\t\t\t\ti += 1;\n\t\t\t\t\t\tc = s.charAt(i);\n\t\t\t\t\t\tif (c === DQ || c === BS || c === DS) {\n\t\t\t\t\t\t\tout += c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tout += BS + c;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (c === DS) {\n\t\t\t\t\t\tout += parseEnvVar();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tout += c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (c === DQ || c === SQ) {\n\t\t\t\tquote = c;\n\t\t\t} else if (controlRE.test(c)) {\n\t\t\t\treturn { op: s };\n\t\t\t} else if (hash.test(c)) {\n\t\t\t\tcommented = true;\n\t\t\t\tvar commentObj = { comment: string.slice(match.index + i + 1) };\n\t\t\t\tif (out.length) {\n\t\t\t\t\treturn [out, commentObj];\n\t\t\t\t}\n\t\t\t\treturn [commentObj];\n\t\t\t} else if (c === BS) {\n\t\t\t\tesc = true;\n\t\t\t} else if (c === DS) {\n\t\t\t\tout += parseEnvVar();\n\t\t\t} else {\n\t\t\t\tout += c;\n\t\t\t}\n\t\t}\n\n\t\tif (isGlob) {\n\t\t\treturn { op: 'glob', pattern: out };\n\t\t}\n\n\t\treturn out;\n\t}).reduce(function (prev, arg) { // finalize parsed arguments\n\t\t// TODO: replace this whole reduce with a concat\n\t\treturn typeof arg === 'undefined' ? prev : prev.concat(arg);\n\t}, []);\n}\n\nmodule.exports = function parse(s, env, opts) {\n\tvar mapped = parseInternal(s, env, opts);\n\tif (typeof env !== 'function') {\n\t\treturn mapped;\n\t}\n\treturn mapped.reduce(function (acc, s) {\n\t\tif (typeof s === 'object') {\n\t\t\treturn acc.concat(s);\n\t\t}\n\t\tvar xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n\t\tif (xs.length === 1) {\n\t\t\treturn acc.concat(xs[0]);\n\t\t}\n\t\treturn acc.concat(xs.filter(Boolean).map(function (x) {\n\t\t\tif (startsWithToken.test(x)) {\n\t\t\t\treturn JSON.parse(x.split(TOKEN)[1]);\n\t\t\t}\n\t\t\treturn x;\n\t\t}));\n\t}, []);\n};\n","'use strict';\n\nmodule.exports = function quote(xs) {\n\treturn xs.map(function (s) {\n\t\tif (s && typeof s === 'object') {\n\t\t\treturn s.op.replace(/(.)/g, '\\\\$1');\n\t\t}\n\t\tif ((/[\"\\s]/).test(s) && !(/'/).test(s)) {\n\t\t\treturn \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n\t\t}\n\t\tif ((/[\"'\\s]/).test(s)) {\n\t\t\treturn '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n\t\t}\n\t\treturn String(s).replace(/([A-Za-z]:)?([#!\"$&'()*,:;<=>?@[\\\\\\]^`{|}])/g, '$1\\\\$2');\n\t}).join(' ');\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.shift();\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","import { parse } from \"shell-quote\";\r\n\r\n/**\r\n * Removes the ANSI escape codes from the given input\r\n */\r\nexport function removeANSI(input) {\r\n  return input.toString().replace(/\\x1B\\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]/g, '')\r\n}\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Returns the word at the given offset.\r\n */\r\nexport function calcWidth(str) {\r\n  let acc= 0;\r\n  for (let i = 0; i < str.length; ++i) {\r\n    const c = str.charAt(i);\r\n    // Zero width\r\n    if(/[\\u200B-\\u200D\\uFEFF]/g.test(c)) {\r\n      acc += 0;\r\n    }\r\n    // Special characters\r\n    else if(/[\\u0591-\\u05F4\\uFB1D-\\uFBF4]/g.test(c)) {\r\n      acc += 0;\r\n    }\r\n    // Wide characters\r\n    else if(/[\\u1100-\\u115F\\u11A3-\\u11A7\\u11FA-\\u11FF\\u2329-\\u232A\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E\\u3041-\\u3096\\u3099-\\u30FF\\u3105-\\u312F\\u3131-\\u318E\\u3190-\\u31BA\\u31C0-\\u31E3\\u31F0-\\u31FF\\u3200-\\u321E\\u3220-\\u3247\\u3250-\\u32FE\\u3300-\\u33FF\\u3400-\\u4DBF\\u4E00-\\u9FFC\\uA000-\\uA48C\\uA490-\\uA4C6\\uA960-\\uA97C\\uAC00-\\uD7A3\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE66\\uFE68-\\uFE6B\\uFF01-\\uFF60\\uFFE0-\\uFFE6]/g.test(c)) {\r\n      acc += 2;\r\n    }\r\n    // Combining characters\r\n    else acc += 1;\r\n  }\r\n  return acc;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let ansi_input = input\r\n  input = removeANSI(input)\r\n  offset -= (ansi_input.length - input.length)\r\n  \r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += calcWidth(chr);\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\]?[ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  removeANSI,\r\n  calcWidth,\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n\r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n\r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n\r\n    String.prototype.__defineGetter__(\"width\", function () { return calcWidth(this) });\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return this.println(\"\");\r\n    items = items.map(removeANSI);\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.width), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.width);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substring(0, offset));\r\n    return newInput.length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substring(0, _cursor - 1) + _input.substring(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substring(0, _cursor) + _input.substring(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substring(0, _cursor) + data + _input.substring(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substring(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substring(0, ofs) + this._input.substring(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substring(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace && inputFragment.length > 0) {\r\n                this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              const lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substring(lastToken.length) + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const lastToken = getLastToken(inputFragment);\r\n              const sameFragment = getSharedFragment(lastToken, candidates);\r\n\r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                this.handleCursorInsert(\r\n                  sameFragment.substring(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // if there's no shared fragment to complete, print the candidates\r\n              if((sameFragment?.length || 0) <= lastToken.length) {\r\n                // If we are less than maximum auto-complete candidates, print\r\n                // them to the user and re-start prompt\r\n                this.printAndRestartPrompt(() => {\r\n                  this.printWide(candidates);\r\n                });\r\n              }\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"names":["exports","parse","CONTROL","join","controlRE","RegExp","META","hash","TOKEN","i","Math","random","toString","startsWithToken","module","s","env","opts","mapped","string","BS","escape","chunker","matches","r","matchObj","origIndex","lastIndex","exec","push","index","matchAll","length","commented","map","match","test","op","quote","esc","out","isGlob","c","charAt","parseEnvVar","commentObj","comment","slice","pattern","varend","varname","char","Error","indexOf","slicedFromI","pre","key","JSON","stringify","getVar","reduce","prev","arg","concat","parseInternal","acc","xs","split","filter","Boolean","x","replace","String","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","HistoryController","size","_classCallCheck","this","entries","cursor","value","entry","trim","shift","idx","max","min","removeANSI","input","wordBoundaries","leftSide","arguments","words","rx","closestLeftBoundary","offset","found","reverse","find","calcWidth","str","offsetToColRow","maxCols","ansi_input","row","col","chr","countLines","hasTailingWhitespace","getLastToken","pop","getSharedFragment","fragment","candidates","oldFragment","startsWith","LocalEchoController","term","options","_handleTermData","handleTermData","bind","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","__defineGetter__","detach","off","forEach","dispose","on","onData","onResize","fn","_len","args","Array","_key","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","_this2","reason","message","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","substring","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","callback","_this3","setCursor","resume","setInput","ret","then","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","backspace","data","_this4","charCodeAt","normData","from","handleData","_this5","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","hasTailingSpace","callbacks","tokens","expr","_ref","apply","console","error","txt","collectAutocompleteCandidates","sort","lastToken","sameFragment","printAndRestartPrompt","printWide","readChar","yn","rewind"],"sourceRoot":""}